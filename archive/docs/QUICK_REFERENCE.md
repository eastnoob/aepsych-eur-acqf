"""
【快速参考卡】多尺度 & 学习型扰动

═══════════════════════════════════════════════════════════════════════════════

【核心概念速览】

多尺度扰动（Multi-Scale Perturbation）
  ├─ 问题：不同位置需要不同尺度的信息
  ├─ 方案：在 [细0.05, 中0.15, 粗0.3] 三个尺度各采几个点
  ├─ 适用：有S曲线、分级、非线性响应
  └─ 收益：+10-15% 性能，快速原型最佳

学习型扰动（Learned Perturbation Distribution）
  ├─ 问题：不同维的学习速度不同
  ├─ 方案：根据参数方差历史动态调整扰动幅度
  ├─ 适用：某些维难学，某些容易的混合
  └─ 收益：+15-20% 性能，长期实验最佳

═══════════════════════════════════════════════════════════════════════════════

【一句话总结】

  多尺度：「洋葱式覆盖」= 既看细节，也看全局
  学习型：「自适应调整」= 根据学习进度实时调整探索策略

═══════════════════════════════════════════════════════════════════════════════

【应用决策树】

  Start
    │
    ├─ Q1: 有S曲线/分级/非线性吗？
    │  ├─ YES → Step2
    │  └─ NO → Step3
    │
    ├─ Step2: Q2: 维度学习不均吗？
    │  ├─ YES → 「多尺度+学习型」← ⭐ 最优
    │  └─ NO  → 「多尺度」      ← 性价比高
    │
    └─ Step3: Q2: 维度学习不均吗？
       ├─ YES → 「学习型」      ← 自适应强
       └─ NO  → 「固定扰动」    ← 保持简单

═══════════════════════════════════════════════════════════════════════════════

【具体应用】

 场景 | 特征 | 推荐 | 预期收益 | 难度
─────┼──────┼──────┼──────────┼──────
心理物理 | S曲线✓ 难学维✓ | 多+学 | +25-30% | ⭐⭐⭐
工业DOE | 线性✗ 难学维✓ | 学习型 | +15-20% | ⭐⭐
用户研究 | 线性✗ 均衡✗ | 固定 | — | ⭐
植物优化 | 非线✓ 难学维✓ | 多+学 | +25-30% | ⭐⭐⭐

═══════════════════════════════════════════════════════════════════════════════

【性能对标】

  固定扰动：         ──────────────────────────────   基准
  多尺度：          ────────────────────────────────── +10-15%
  学习型：          ────────────────────────────────── +15-20%
  多尺度+学习型：   ──────────────────────────────────── +25-30%

═══════════════════════════════════════════════════════════════════════════════

【成本分析】

  方案        | 实现难度 | 计算成本 | 参数调整 | 推荐度
  ────────────┼──────────┼──────────┼──────────┼────────
  多尺度      | ⭐⭐   | 0-2%    | 3-4个   | 🟢🟢
  学习型      | ⭐⭐⭐ | 0-3%    | 自动    | 🟡
  两者结合    | ⭐⭐⭐ | 2-5%    | 3-4个   | 🟢

═══════════════════════════════════════════════════════════════════════════════

【代码片段】

1️⃣ 启用多尺度：

   acqf = EURAnovaPairAcqfEnhanced(
       model=model,
       use_multiscale=True,
       multiscale_config=MultiScaleConfig(
           scales=[0.05, 0.15, 0.3],
           points_per_scale=2
       )
   )

2️⃣ 启用学习型：

   acqf = EURAnovaPairAcqfEnhanced(
       model=model,
       use_learned_perturbation=True,
       # 自动在 forward() 时更新
   )

3️⃣ 同时启用（最优）：

   acqf = EURAnovaPairAcqfEnhanced(
       model=model,
       use_multiscale=True,
       use_learned_perturbation=True,
       multiscale_config=MultiScaleConfig(
           scales=[0.05, 0.15],
           points_per_scale=2
       )
   )

═══════════════════════════════════════════════════════════════════════════════

【常见陷阱】

❌ 误区1：总是用最复杂的方案
  ✓ 正确：根据问题特征选择，简单有时更好

❌ 误区2：多尺度会导致点数爆炸
  ✓ 正确：虽然点数增加，但通过批量并行优化，反而更快

❌ 误区3：学习型需要手动调参
  ✓ 正确：自动从数据推导，无需手动配置

❌ 误区4：小实验用多尺度太复杂
  ✓ 正确：<15 trials 最适合用多尺度（性价比最高）

═══════════════════════════════════════════════════════════════════════════════

【快速诊断】

如果你发现以下现象，可能需要改进：

 现象 | 可能原因 | 解决方案
──────┼──────────┼──────────────────
收敛慢 | 探索不足 | 加多尺度或学习型
精度差 | 探索过度 | 调整超参或启用动态γ
交互难发现 | 局部采样 | 加学习型的跳跃机制
某维进度慢 | 学习不均 | 启用学习型

═══════════════════════════════════════════════════════════════════════════════

【推荐学习路径】

初阶：

  1. 理解为什么需要这两个改进（FINAL_SUMMARY.md）
  2. 看应用决策表，判断自己的问题类型
  3. 决定是否使用

中阶：
  4. 阅读代码实现（multiscale_learned_implementation.py）
  5. 理解多尺度和学习型的机制
  6. 在自己的项目中尝试

高阶：
  7. 运行演示程序（demo_comparison.py）
  8. 对比不同方案的性能
  9. 根据结果微调超参数

═══════════════════════════════════════════════════════════════════════════════

【核心参数一览】

多尺度参数：
  scales: [0.05, 0.15, 0.3]      # 三个尺度，可自定义
  points_per_scale: 2              # 每个尺度2个点，共6个（vs原来4个）

学习型参数：
  use_dynamic_lambda: True          # 基于参数方差的动态权重
  tau_n_min/max: 3, 25             # 样本数阈值
  gamma_min/max: 0.05, 0.5         # 信息/覆盖权重范围

# 其余参数自动从数据推导

═══════════════════════════════════════════════════════════════════════════════

【关键文件】

📄 FINAL_SUMMARY.md
   完整的技术总结，包含所有细节

📄 multiscale_learned_implementation.py
   代码框架和接口定义

📄 demo_comparison.py
   交互式演示和对比分析

📄 single_vs_multiscale.png
   可视化对比图表（运行 demo_comparison.py 生成）

═══════════════════════════════════════════════════════════════════════════════

【下一步】

✅ 已完成：理解两个改进方向的概念和应用场景
⏭️ 下一步：评估自己的问题是否需要这些改进
⏭️ 最后：在实际项目中测试和微调

"""
