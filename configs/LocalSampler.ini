# LocalSampler 局部扰动采样器配置
#
# 为每个候选点生成局部扰动变体，支持混合变量类型
# - 分类变量：从历史值离散采样
# - 整数变量：高斯扰动后舍入
# - 连续变量：标准高斯扰动
#
# 工作流程：
#   [1] 遍历设计空间的候选点
#   [2] 对每个候选点周围生成local_num个扰动变体
#   [3] 对扰动变体评估采集函数值
#   [4] 选择具有最高采集值的变体
#   [5] 返回该变体作为建议点

[LocalSampler]

# ========== 扰动幅度控制 ==========

# 局部扰动标准差（相对特征范围）
# 类型: float
# 默认: 0.1
# 范围: 0.02 - 0.3
# 说明: 高斯扰动的标准差 = local_jitter_frac × feature_range
#   公式: σ = local_jitter_frac × (max - min)
#   0.1: 推荐值（±10%范围扰动）
#   <0.05: 扰动太小，覆盖不足
#   0.2: 中等扰动
#   >0.3: 扰动过大，局部性丧失
#
# 直观理解（假设特征范围为[0, 1]）：
#   local_jitter_frac=0.05 → σ=0.05
#   local_jitter_frac=0.10 → σ=0.10  # 推荐
#   local_jitter_frac=0.20 → σ=0.20
local_jitter_frac = 0.1

# ========== 扰动样本数（手动配置） ==========

# 每个候选点的局部扰动样本数
# 类型: int
# 默认: 4
# 范围: 2 - 20
# 说明: 每个候选点生成的扰动变体数
#   2-3: 最小化计算成本（快速但不足）
#   4: 推荐值（效率与覆盖平衡）
#   8-12: 充分采样（计算成本上升）
#   >16: 计算成本过高，收益递减
#
# 计算成本估计：
#   局部采样时间 = local_num × 采集函数评估时间
#   例: local_num=4, 采集函数=10ms → 40ms/候选点
local_num = 4

# ========== 随机种子 ==========

# 扰动采样的随机种子
# 类型: int 或 None
# 默认: 42
# 说明: 控制扰动的随机性和可复现性
#   42: 固定种子（完全可复现）
#   None: 无种子（每次随机）
#   其他整数: 其他固定种子
# 用途:
#   开发/调试: 用固定种子（可复现）
#   生产运行: 用None或动态种子（更多样性）
random_seed = 42

# ========== 混合扰动策略（新增） ==========

# 启用混合扰动策略
# 类型: bool
# 默认: false
# 说明: 是否对低水平离散变量使用穷举组合
#   true: 结合穷举(低水平)和高斯采样(高水平)
#   false: 所有离散变量均用高斯采样（传统，推荐）
#
# 场景对比：
#   false (传统): 所有变量用高斯→快速但可能遗漏离散组合
#   true (混合):  低水平穷举→覆盖完整，成本取决于水平数
#
# 例子（4维，变量类型：[2-level cat, 3-level cat, continuous, integer]）：
#   false: 两个分类维都用高斯扰动→可能遗漏某些(level,level)组合
#   true:  (2×3=6)组合穷举，continuous和integer用高斯→更全面
use_hybrid_perturbation = false

# 穷举策略的水平阈值
# 类型: int
# 默认: 3
# 范围: 2 - 5
# 说明: 有多少水平以下的离散变量使用穷举（当use_hybrid=true）
#   2: 仅2水平变量穷举（如二元分类）
#   3: ≤3水平用穷举（推荐，平衡）
#   4: ≤4水平用穷举（更激进）
#   >4: 穷举成本指数增长
#
# 水平数对穷举成本的影响：
#   3个2-level变量 → 穷举数=2×2×2=8个组合
#   3个3-level变量 → 穷举数=3×3×3=27个组合 ⚠️
#   2个2-level + 2个3-level → 2×2×3×3=36个组合 ⚠️⚠️
#
# 建议：
#   总穷举数<10: 安全
#   总穷举数10-20: 可接受
#   总穷举数>30: 考虑提高阈值或禁用混合
exhaustive_level_threshold = 3

# 穷举采样的循环填充
# 类型: bool
# 默认: true
# 说明: 当穷举值数<local_num时是否循环填充
#   true: 循环覆盖至local_num（推荐）
#   false: 截断至实际穷举数
#
# 例子（3水平变量，local_num=5）：
#   穷举组合: [0, 1, 2]（3个）
#   true  → [0, 1, 2, 0, 1]（循环覆盖，5个）
#   false → [0, 1, 2]（截断，3个<local_num）
#
# 选择建议：
#   true: 保证生成local_num个样本，均衡采样
#   false: 严格遵循实际组合数，某些样本可能不足
exhaustive_use_cyclic_fill = true

# ========== 自动计算Local Num（新增） ==========

# 启用local_num自动计算
# 类型: bool
# 默认: false
# 说明: 是否根据离散变量水平自动计算最优local_num
#   true: 基于低水平离散变量的最小公倍数自动计算
#   false: 使用手动设置的local_num值（推荐）
#
# 自动计算公式：
#   1. 收集所有≤exhaustive_level_threshold的离散变量的水平数
#   2. 计算这些数的最小公倍数(LCM)
#   3. 取 min(LCM, auto_local_num_max)
#
# 场景对比：
#   手动local_num=4: 固定4个样本，简单
#   自动local_num:   根据离散结构自适应，更优但需要计算
#
# 例子：
#   变量: [2-level, 3-level, continuous]
#   自动计算: LCM(2,3) = 6 → local_num=min(6, auto_local_num_max)
#   手动设置: local_num=4
auto_compute_local_num = false

# 自动计算的local_num上限
# 类型: int
# 默认: 12
# 范围: 4 - 30
# 说明: 自动计算时的最大值（避免成本爆炸）
#   12: 推荐值（通常LCM<12）
#   <8: 过度限制，可能低于实际需求
#   >20: 计算成本高，收益递减
#
# 与exhaustive_level_threshold的交互：
#   threshold=3, auto_num_max=12:
#     最坏情况LCM(2,2,3,3) = 12 → 可接受
#   threshold=4, auto_num_max=12:
#     最坏情况LCM(2,2,3,4) = 12 → 勉强
#     LCM(3,3,4) = 36 → 被限制到12 ⚠️
auto_local_num_max = 12

# ========== 变量类型配置 ==========

# 各维度的变量类型
# 类型: str或dict
# 默认: None（自动推断或均默认continuous）
# 格式:
#   - 逗号分隔: "categorical, continuous, integer, categorical"
#   - 缩写: "c,c,i,c"（c=categorical, i=integer, 其他=continuous）
#   - 字典: {0: 'categorical', 2: 'integer'}
# 说明: 为每个维度指定扰动方法
#   categorical: 离散型，从历史值中采样
#   continuous: 连续型，高斯扰动
#   integer: 整数型，高斯扰动后舍入
#
# 例子：
#   # 心理物理实验：颜色(分类), 亮度(连续), 对比度(连续)
#   variable_types_list = "categorical, continuous, continuous"
#
#   # 材料实验：材料(分类), 温度(连续), 压力(连续), 浓度(连续)
#   variable_types_list = "categorical, continuous, continuous, continuous"
#
#   # 混合设计：性别(分类), 年龄(整数), pH值(连续)
#   variable_types_list = "categorical, integer, continuous"
variable_types_list = None

# ========== Gower距离权重（ARD） ==========

# Gower距离中各维度的权重
# 类型: str或list
# 默认: None（所有维度权重相等）
# 格式:
#   - 逗号分隔: "1.0, 2.0, 1.0"
#   - 列表: [1.0, 2.0, 1.0]
#   - "auto": 基于熵自动计算
# 说明: 在Gower距离计算中为各维度分配权重
#   1.0: 标准权重（基准）
#   >1.0: 该维度权重提升（重视其距离）
#   <1.0: 该维度权重降低（弱化其距离）
#   "auto": 信息熵高的维度权重更低（信息论原则）
#
# 场景：
#   # 均匀权重（默认）
#   ard_weights = None
#
#   # 强调第一个维度（如最重要参数）
#   ard_weights = "2.0, 1.0, 1.0"
#
#   # 自适应权重（基于数据分布）
#   ard_weights = "auto"
#
# 与coverage_method的交互：
#   coverage_method=min_distance: ARD用于加权欧氏距离
#   coverage_method=gower_distance: ARD用于Gower混合距离
ard_weights = None
